<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>tesis-forntend documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>
          <script>
              // --- Iframe navigation tracking for Template Playground ---
              function sendCurrentUrlToParent() {
                  if (window.parent && window.parent !== window) {
                      window.parent.postMessage({
                          type: 'compodoc-iframe-navigate',
                          url: window.location.pathname + window.location.hash
                      }, '*');
                  }
              }
              window.addEventListener('hashchange', sendCurrentUrlToParent, false);
              window.addEventListener('popstate', sendCurrentUrlToParent, false);
              window.addEventListener('DOMContentLoaded', sendCurrentUrlToParent, false);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">tesis-forntend documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">

















<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  Window</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/pages/private/learning/course/content/content.component.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#onYouTubeIframeAPIReady" 
>
                                            onYouTubeIframeAPIReady
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#YT" 
>
                                            YT
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="onYouTubeIframeAPIReady"></a>
                                        <span class="name "><b>onYouTubeIframeAPIReady</b>
                                            <a href="#onYouTubeIframeAPIReady">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>onYouTubeIframeAPIReady:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function" target="_blank" >function</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/function" target="_blank" >function</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="YT"></a>
                                        <span class="name "><b>YT</b>
                                            <a href="#YT">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>YT:         <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Component,
  inject,
  OnInit,
  signal,
  computed,
  DestroyRef,
  ViewChild,
  ElementRef
} from &#x27;@angular/core&#x27;;
import { CommonModule } from &#x27;@angular/common&#x27;;
import { ActivatedRoute, NavigationStart, Router } from &#x27;@angular/router&#x27;;
import { DomSanitizer, SafeResourceUrl } from &#x27;@angular/platform-browser&#x27;;

import { WatchingService } from &#x27;../../../../../core/api/watching/watching.service&#x27;;
import { ButtonComponent } from &#x27;../../../../../shared/UI/components/button/button/button.component&#x27;;
import { IconComponent } from &#x27;../../../../../shared/UI/components/button/icon/icon.component&#x27;;
import { AvatarComponent } from &#x27;../../../../../shared/UI/components/media/avatar/avatar.component&#x27;;

import { ContentResponse } from &#x27;../../../../../core/api/watching/content.interface&#x27;;
import { Subject, of, interval } from &#x27;rxjs&#x27;;
import {
  auditTime,
  catchError,
  distinctUntilChanged,
  filter,
  map,
  switchMap,
  takeUntil,
  tap
} from &#x27;rxjs/operators&#x27;;
import { takeUntilDestroyed } from &#x27;@angular/core/rxjs-interop&#x27;;
import { FeedbackService } from &#x27;../../../../../core/api/feedback/feedback.service&#x27;;
import { LikeResponse, SavedResponse } from &#x27;../../../../../core/api/feedback/feedback.interface&#x27;;
import { CourseBridge } from &#x27;../../../../../core/api/watching/course-bridge.service&#x27;;
import { DialogComponent } from &#x27;../../../../../shared/UI/components/overlay/dialog/dialog.component&#x27;;

import { NotificationBridgeService } from &#x27;../../../../../core/api/notification/notification-bridge.service&#x27;;

import { TextComponent } from &#x27;../../../../../shared/UI/components/data/text/text.component&#x27;;

declare global {
  interface Window { onYouTubeIframeAPIReady?: () &#x3D;&gt; void; YT?: any; }
}

@Component({
  selector: &#x27;app-content&#x27;,
  standalone: true,
  imports: [
    CommonModule,
    IconComponent,
    ButtonComponent,
    AvatarComponent,
    DialogComponent,
    TextComponent
  ],
  templateUrl: &#x27;./content.component.html&#x27;,
  styleUrl: &#x27;./content.component.css&#x27;
})
export class ContentComponent implements OnInit {
  private readonly route &#x3D; inject(ActivatedRoute);
  private readonly router &#x3D; inject(Router);
  private readonly watchingSvc &#x3D; inject(WatchingService);
  private readonly sanitizer &#x3D; inject(DomSanitizer);
  private readonly destroyRef &#x3D; inject(DestroyRef);
  private readonly feedbackSvc &#x3D; inject(FeedbackService);
  private readonly bridge &#x3D; inject(CourseBridge);
  private readonly notificationBridge &#x3D; inject(NotificationBridgeService);
  

  @ViewChild(&#x27;ytFrame&#x27;) ytFrame?: ElementRef&lt;HTMLIFrameElement&gt;;
  @ViewChild(&#x27;codeInput&#x27;) codeInput?: ElementRef&lt;HTMLInputElement&gt;;

  // state
  readonly loading &#x3D; signal(true);
  readonly error &#x3D; signal&lt;string | null&gt;(null);
  readonly data &#x3D; signal&lt;ContentResponse | null&gt;(null);
  readonly liking &#x3D; signal(false);
  readonly saving &#x3D; signal(false);

  dialogCodeShow &#x3D; false;
  dialogPdfShow &#x3D; false;

  // YouTube embed cache (no re-render en likes/saves)
  readonly ytEmbedRaw &#x3D; signal&lt;string | null&gt;(null);
  readonly ytSafeSrc &#x3D; computed&lt;SafeResourceUrl | null&gt;(() &#x3D;&gt; {
    const raw &#x3D; this.ytEmbedRaw();
    return raw ? this.sanitizer.bypassSecurityTrustResourceUrl(raw) : null;
  });

  // helpers tipo de contenido
  readonly isYouTube &#x3D; computed(
    () &#x3D;&gt; (this.data()?.learning_meta?.type || &#x27;&#x27;).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;youtube&#x27;
  );

  readonly isArchive &#x3D; computed(() &#x3D;&gt;
    [&#x27;archivo&#x27;, &#x27;archive&#x27;, &#x27;file&#x27;].includes(
      (this.data()?.learning_meta?.type || &#x27;&#x27;).toLowerCase()
    )
  );

  readonly isVideoFile &#x3D; computed(() &#x3D;&gt;
    [&#x27;mp4&#x27;, &#x27;webm&#x27;, &#x27;ogg&#x27;, &#x27;mov&#x27;, &#x27;m4v&#x27;].includes(
      (this.data()?.learning_meta?.format || &#x27;&#x27;).toLowerCase()
    )
  );

  readonly isPdf &#x3D; computed(() &#x3D;&gt;
    this.isArchive() &amp;&amp;
    (this.data()?.learning_meta?.format || &#x27;&#x27;).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;pdf&#x27;
  );

  readonly isImageFile &#x3D; computed(() &#x3D;&gt;
    this.isArchive() &amp;&amp;
    [&#x27;png&#x27;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;gif&#x27;, &#x27;webp&#x27;, &#x27;bmp&#x27;, &#x27;svg&#x27;].includes(
      (this.data()?.learning_meta?.format || &#x27;&#x27;).toLowerCase()
    )
  );

  readonly isTmpFile &#x3D; computed(() &#x3D;&gt;
    this.isArchive() &amp;&amp;
    (this.data()?.learning_meta?.format || &#x27;&#x27;).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;tmp&#x27;
  );

  readonly pdfSafeSrc &#x3D; computed&lt;SafeResourceUrl | null&gt;(() &#x3D;&gt; {
    const d &#x3D; this.data();
    const format &#x3D; (d?.learning_meta?.format || &#x27;&#x27;).toLowerCase();
    const url &#x3D; d?.learning_content?.url;
    if (format !&#x3D;&#x3D; &#x27;pdf&#x27; || !url) return null;
    return this.sanitizer.bypassSecurityTrustResourceUrl(url);
  });

  // ---- Progreso en tiempo real ----
  private progress$ &#x3D; new Subject&lt;number&gt;(); // segundos en vivo
  private lastSentSecond &#x3D; -1;               // anti-duplicados
  private ytPlayer: any &#x3D; null;              // instancia YT.Player
  private ytTickStop$ &#x3D; new Subject&lt;void&gt;(); // parar polling YT

  private lastHtml5Time &#x3D; 0; // último segundo visto en &lt;video&gt;
  private lastYtTime &#x3D; 0;    // último segundo visto en YouTube

  // ---- Completed Chapter (progreso %)
  private lastPercentReported &#x3D; 0;       // último % reportado al backend
  private readonly minDeltaPercent &#x3D; 0.5; // evita spam: no mandar deltas &lt; 0.5%

  // ---- Registro (código de acceso) ----
  readonly codeLength &#x3D; 7;
  readonly code &#x3D; signal&lt;string&gt;(&#x27;&#x27;);
  readonly enrolling &#x3D; signal(false);
  readonly codeError &#x3D; signal&lt;string | null&gt;(null);

  // ---------- Local backup ----------
  private resumeKey(lcId: number | string) {
    return &#x60;resume:${lcId}&#x60;;
  }
  private saveResumeLocal(lcId: number | string, sec: number) {
    try {
      localStorage.setItem(
        this.resumeKey(lcId),
        JSON.stringify({ sec: Math.floor(sec), ts: Date.now() })
      );
    } catch {}
  }
  private readResumeLocal(
    lcId: number | string
  ): { sec: number; ts: number } | null {
    try {
      const raw &#x3D; localStorage.getItem(this.resumeKey(lcId));
      if (!raw) return null;
      const v &#x3D; JSON.parse(raw);
      if (typeof v?.sec &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; typeof v?.ts &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) return v;
    } catch {}
    return null;
  }

  isRegistered &#x3D; computed(() &#x3D;&gt; this.bridge.isRegistered());

  ngOnInit(): void {
    // a) Canal de progreso con throttling 4s
    this.progress$
      .pipe(
        map((s) &#x3D;&gt; Math.max(0, Math.floor(s))),
        distinctUntilChanged(),
        auditTime(4000),
        switchMap((sec) &#x3D;&gt; this.sendProgress(sec)),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe();

    // b) Cargar contenido por capítulo
    const parent &#x3D; this.route.parent ?? this.route;

    parent.paramMap
      .pipe(
        map((pm) &#x3D;&gt; pm.get(&#x27;chapterId&#x27;)),
        filter((id): id is string &#x3D;&gt; !!id),
        distinctUntilChanged(),
        tap(() &#x3D;&gt; {
          this.loading.set(true);
          this.error.set(null);
        }),
        switchMap((chapterId) &#x3D;&gt;
          this.watchingSvc.getChapterContent(chapterId).pipe(
            catchError((err) &#x3D;&gt; {
              this.error.set(
                err?.error?.message || &#x27;No se pudo cargar el contenido.&#x27;
              );
              return of(null);
            })
          )
        ),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe((res) &#x3D;&gt; {
        if (res) this.setDataAndPreparePlayers(res);
        this.loading.set(false);
      });

    // c) Primera carga por snapshot
    const initialId &#x3D; parent.snapshot.paramMap.get(&#x27;chapterId&#x27;);
    if (initialId) {
      this.loading.set(true);
      this.watchingSvc.getChapterContent(initialId).subscribe({
        next: (res) &#x3D;&gt; {
          this.setDataAndPreparePlayers(res);
          this.loading.set(false);
        },
        error: (err) &#x3D;&gt; {
          this.error.set(
            err?.error?.message || &#x27;No se pudo cargar el contenido.&#x27;
          );
          this.loading.set(false);
        }
      });
    }

    // d) Flush al ocultar pestaña / salir / navegar
    const onVisibility &#x3D; () &#x3D;&gt; this.flushNowFromCurrentPlayer();
    const onBeforeUnload &#x3D; () &#x3D;&gt; this.flushNowFromCurrentPlayer(true);
    document.addEventListener(&#x27;visibilitychange&#x27;, onVisibility);
    window.addEventListener(&#x27;beforeunload&#x27;, onBeforeUnload);

    this.router.events
      .pipe(
        filter((ev) &#x3D;&gt; ev instanceof NavigationStart),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe(() &#x3D;&gt; this.flushNowFromCurrentPlayer());

    this.destroyRef.onDestroy(() &#x3D;&gt; {
      document.removeEventListener(&#x27;visibilitychange&#x27;, onVisibility);
      window.removeEventListener(&#x27;beforeunload&#x27;, onBeforeUnload);
      this.destroyYouTubePlayer();
    });
  }

  // -----------------------------
  // Carga/prepare players por tipo
  // -----------------------------
  private setDataAndPreparePlayers(res: ContentResponse) {
    // reset de memorias por capítulo
    this.lastPercentReported &#x3D; 0;
    this.lastHtml5Time &#x3D; 0;
    this.lastYtTime &#x3D; 0;
    this.lastSentSecond &#x3D; -1;

    // aplica respaldo local (si es más reciente que servidor)
    const lcId &#x3D; res?.learning_content?.id;
    const serverSec &#x3D; res?.last_view?.second_seen ?? 0;
    if (lcId !&#x3D; null) {
      const local &#x3D; this.readResumeLocal(lcId);
      if (local &amp;&amp; local.sec &gt;&#x3D; 0) {
        const useLocal &#x3D;
          local.ts &gt;
            (res?.last_view?.updated_at
              ? new Date(res.last_view.updated_at).getTime()
              : 0) || local.sec &gt; serverSec;

        if (useLocal) {
          res &#x3D; {
            ...res,
            last_view: {
              ...res.last_view,
              second_seen: local.sec,
              updated_at: new Date(local.ts).toISOString()
            } as any
          };
          this.sendProgress(local.sec).subscribe();
        }
      }
    }

    this.data.set(res);
    this.updateYouTubeEmbedFromResponse(res);

    if (this.isYouTube()) {
      queueMicrotask(() &#x3D;&gt; this.initYouTubePlayerIfNeeded());
    } else {
      this.destroyYouTubePlayer();
    }
  }

  /** Calcula y fija el embed URL de YouTube con enablejsapi y start */
  private updateYouTubeEmbedFromResponse(res: ContentResponse | null): void {
    if (
      res &amp;&amp;
      (res.learning_meta?.type || &#x27;&#x27;).toLowerCase() &#x3D;&#x3D;&#x3D; &#x27;youtube&#x27; &amp;&amp;
      res.learning_content?.url
    ) {
      const start &#x3D; res.last_view?.second_seen || 0;
      const embed &#x3D; this.buildYouTubeEmbed(res.learning_content.url, start);
      this.ytEmbedRaw.set(embed);
    } else {
      this.ytEmbedRaw.set(null);
    }
  }

  // ---- UI Actions (optimistic) ----
  toggleLike(): void {
    const d &#x3D; this.data();
    if (!d) return;

    const chapterId &#x3D; d.chapter.id;
    const prevLiked &#x3D; d.user_state.liked_chapter;
    const nextLiked &#x3D; !prevLiked;

    const prevLikes &#x3D; d.likes_total ?? 0;
    this.data.set({
      ...d,
      user_state: { ...d.user_state, liked_chapter: nextLiked },
      likes_total: nextLiked ? prevLikes + 1 : Math.max(0, prevLikes - 1)
    });

    this.liking.set(true);
    this.feedbackSvc.setLiked(chapterId, nextLiked).subscribe({
      next: (res: LikeResponse) &#x3D;&gt; {
        const cur &#x3D; this.data();
        if (!cur) return;
        if (res.liked !&#x3D;&#x3D; cur.user_state.liked_chapter) {
          const likes &#x3D; cur.likes_total ?? 0;
          this.data.set({
            ...cur,
            user_state: { ...cur.user_state, liked_chapter: res.liked },
            likes_total: res.liked ? likes + 1 : Math.max(0, likes - 1)
          });
        }
        this.liking.set(false);
      },
      error: () &#x3D;&gt; {
        const cur &#x3D; this.data();
        if (!cur) return;
        this.data.set({
          ...cur,
          user_state: { ...cur.user_state, liked_chapter: prevLiked },
          likes_total: prevLiked ? prevLikes : Math.max(0, prevLikes)
        });
        this.liking.set(false);
      }
    });
  }

  toggleSaved(): void {
    const d &#x3D; this.data();
    if (!d) return;

    const routeCourseId &#x3D; this.route.parent?.snapshot.paramMap.get(&#x27;id&#x27;);
    if (!routeCourseId) return;

    const prevSaved &#x3D; d.user_state.is_saved;
    const nextSaved &#x3D; !prevSaved;

    this.data.set({
      ...d,
      user_state: { ...d.user_state, is_saved: nextSaved }
    });

    this.saving.set(true);
    this.feedbackSvc.setSaved(routeCourseId, nextSaved).subscribe({
      next: (res: SavedResponse) &#x3D;&gt; {
        const cur &#x3D; this.data();
        if (!cur) return;
        if (res.saved !&#x3D;&#x3D; cur.user_state.is_saved) {
          this.data.set({
            ...cur,
            user_state: { ...cur.user_state, is_saved: res.saved }
          });
        }
        this.saving.set(false);
      },
      error: () &#x3D;&gt; {
        const cur &#x3D; this.data();
        if (!cur) return;
        this.data.set({
          ...cur,
          user_state: { ...cur.user_state, is_saved: prevSaved }
        });
        this.saving.set(false);
      }
    });
  }

  onRegister(isPrivate: boolean): void {
    const courseId &#x3D; this.courseId;
    if (!courseId) return;

    // Curso público → registro directo
    if (!isPrivate) {
      this.enrolling.set(true);
      this.feedbackSvc.enrollPublic(courseId).subscribe({
        next: () &#x3D;&gt; {
          this.bridge.setRegistered(true);
          this.enrolling.set(false);
        },
        error: (err) &#x3D;&gt; {
          this.codeError.set(
            err?.error?.message || &#x27;No se pudo registrar.&#x27;
          );
          this.enrolling.set(false);
        }
      });
      return;
    }

    // Curso privado → abrir diálogo de código
    this.codeError.set(null);
    this.code.set(&#x27;&#x27;);
    this.dialogCodeShow &#x3D; true;

    setTimeout(() &#x3D;&gt; this.focusCodeInput(), 50);
  }

  // -----------------------------
  // HTML5 video events (archivo)
  // -----------------------------
  onVideoLoadedMetadata(video: HTMLVideoElement): void {
    const start &#x3D; this.data()?.last_view?.second_seen || 0;
    try {
      if (start &gt; 0 &amp;&amp; video?.duration &amp;&amp; start &lt; video.duration) {
        video.currentTime &#x3D; start;
      }
    } catch {}
  }

  onVideoTimeUpdate(video: HTMLVideoElement): void {
    const t &#x3D; video.currentTime || 0;

    // Si hay salto grande (adelanto/retroceso), manda inmediato
    if (Math.abs(t - this.lastHtml5Time) &gt; 1.5) {
      this.flushProgress(t);
    }

    this.progress$.next(t); // tick normal (throttling 4s)
    this.lastHtml5Time &#x3D; t;
  }

  onVideoSeeked(video: HTMLVideoElement): void {
    const t &#x3D; video.currentTime || 0;
    this.lastHtml5Time &#x3D; t; // sincroniza
    this.flushProgress(t);  // flush instantáneo
  }

  onVideoPause(video: HTMLVideoElement): void {
    this.flushProgress(video.currentTime);
  }

  onVideoEnded(video: HTMLVideoElement): void {
    const endSec &#x3D; Number.isFinite(video.duration)
      ? video.duration
      : video.currentTime;
    this.flushProgress(endSec);
  }

  // -----------------------------
  // Envío de progreso (común)
  // -----------------------------
  private get learningContentId(): number | string | null {
    return this.data()?.learning_content?.id ?? null;
  }

  /** Encola el progreso (pasa por throttling de 4s) */
  private sendProgress(sec: number) {
    const lcId &#x3D; this.learningContentId;
    if (lcId &#x3D;&#x3D; null) return of(null);

    const s &#x3D; Math.max(0, Math.floor(sec));
    if (s &#x3D;&#x3D;&#x3D; this.lastSentSecond) return of(null); // evita duplicados
    this.lastSentSecond &#x3D; s;

    // respaldo local por si el usuario recarga muy rápido
    this.saveResumeLocal(lcId, s);
    this.reportCompletedDelta(s);

    return this.feedbackSvc.setContent(lcId, s).pipe(
      catchError(() &#x3D;&gt; of(null))
    );
  }

  /** Flush inmediato (pause/seek/end/ocultar/salir/navegar) */
  private flushProgress(currentSec: number) {
    const sec &#x3D; Math.max(0, Math.floor(currentSec ?? 0));
    this.sendProgress(sec).subscribe();
  }

  /** Detecta player activo y hace flush inmediato */
  private flushNowFromCurrentPlayer(_isUnload &#x3D; false) {
    if (this.isYouTube() &amp;&amp; this.ytPlayer?.getCurrentTime) {
      const sec &#x3D; this.ytPlayer.getCurrentTime();
      this.flushProgress(sec);
      return;
    }
    const videoEl &#x3D;
      document.querySelector&lt;HTMLVideoElement&gt;(&#x27;video.video-player&#x27;);
    if (videoEl) this.flushProgress(videoEl.currentTime || 0);
  }

  // -----------------------------
  // YouTube IFrame API
  // -----------------------------
  private async initYouTubePlayerIfNeeded() {
    if (!this.isYouTube()) return;
    const iframe &#x3D; this.ytFrame?.nativeElement;
    if (!iframe) return;

    await this.ensureYouTubeApi();
    this.destroyYouTubePlayer();

    this.ytPlayer &#x3D; new window.YT.Player(iframe, {
      events: {
        onReady: (e: any) &#x3D;&gt; {
          const start &#x3D; this.data()?.last_view?.second_seen || 0;
          if (start &gt; 0) {
            try {
              e.target.seekTo(start, true);
            } catch {}
          }
        },
        onStateChange: (e: any) &#x3D;&gt; this.onYouTubeStateChange(e)
      }
    });
  }

  private onYouTubeStateChange(e: any) {
    const YT &#x3D; window.YT;
    if (!YT || !this.ytPlayer) return;

    if (e.data &#x3D;&#x3D;&#x3D; YT.PlayerState.PLAYING) {
      // Polling 1s → progress$ + detección de saltos
      this.ytTickStop$.next();
      interval(1000)
        .pipe(takeUntil(this.ytTickStop$), takeUntilDestroyed(this.destroyRef))
        .subscribe(() &#x3D;&gt; {
          const t &#x3D; this.safeGetTimeFromYT();
          if (t &#x3D;&#x3D; null) return;

          if (Math.abs(t - this.lastYtTime) &gt; 1.5) {
            this.flushProgress(t);
          }

          this.progress$.next(t);
          this.lastYtTime &#x3D; t;
        });
    } else if (e.data &#x3D;&#x3D;&#x3D; YT.PlayerState.PAUSED) {
      this.ytTickStop$.next();
      const t &#x3D; this.safeGetTimeFromYT();
      if (t !&#x3D; null) this.flushProgress(t);
    } else if (e.data &#x3D;&#x3D;&#x3D; YT.PlayerState.BUFFERING) {
      const t &#x3D; this.safeGetTimeFromYT();
      if (t !&#x3D; null) this.flushProgress(t);
    } else if (e.data &#x3D;&#x3D;&#x3D; YT.PlayerState.ENDED) {
      this.ytTickStop$.next();
      const t &#x3D;
        this.safeGetDurationFromYT() ?? this.safeGetTimeFromYT() ?? 0;
      this.flushProgress(t);
    }
  }

  private destroyYouTubePlayer() {
    this.ytTickStop$.next();
    try {
      this.ytPlayer?.destroy?.();
    } catch {}
    this.ytPlayer &#x3D; null;
  }

  private safeGetTimeFromYT(): number | null {
    try {
      const t &#x3D; this.ytPlayer?.getCurrentTime?.();
      return typeof t &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; Number.isFinite(t) ? t : null;
    } catch {
      return null;
    }
  }
  private safeGetDurationFromYT(): number | null {
    try {
      const d &#x3D; this.ytPlayer?.getDuration?.();
      return typeof d &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; Number.isFinite(d) ? d : null;
    } catch {
      return null;
    }
  }

  /** Carga el IFrame API una sola vez */
  private ensureYouTubeApi(): Promise&lt;void&gt; {
    return new Promise&lt;void&gt;((resolve) &#x3D;&gt; {
      if (window.YT?.Player) {
        resolve();
        return;
      }

      const existing &#x3D; document.querySelector(
        &#x27;script[data-youtube-api]&#x27;
      ) as HTMLScriptElement | null;
      if (existing) {
        const check &#x3D; () &#x3D;&gt;
          window.YT?.Player ? resolve() : setTimeout(check, 50);
        check();
        return;
      }

      const tag &#x3D; document.createElement(&#x27;script&#x27;);
      tag.src &#x3D; &#x27;https://www.youtube.com/iframe_api&#x27;;
      tag.async &#x3D; true;
      tag.defer &#x3D; true;
      tag.setAttribute(&#x27;data-youtube-api&#x27;, &#x27;true&#x27;);
      document.head.appendChild(tag);

      window.onYouTubeIframeAPIReady &#x3D; () &#x3D;&gt; resolve();
    });
  }

  // ---- YouTube helpers ----
  private buildYouTubeEmbed(rawUrl: string, startSec &#x3D; 0): string | null {
    const id &#x3D; this.extractYouTubeId(rawUrl);
    if (!id) return null;

    const origin &#x3D; window.location.origin;
    const params &#x3D; new URLSearchParams({
      autoplay: &#x27;0&#x27;,
      modestbranding: &#x27;1&#x27;,
      rel: &#x27;0&#x27;,
      controls: &#x27;1&#x27;,
      fs: &#x27;1&#x27;,
      playsinline: &#x27;1&#x27;,
      enablejsapi: &#x27;1&#x27;,
      origin
    });
    if (startSec) params.set(&#x27;start&#x27;, String(Math.floor(startSec)));
    return &#x60;https://www.youtube.com/embed/${id}?${params.toString()}&#x60;;
  }

  private extractYouTubeId(url: string): string | null {
    try {
      const u &#x3D; new URL(url);
      if (u.hostname.includes(&#x27;youtu.be&#x27;))
        return u.pathname.replace(&#x27;/&#x27;, &#x27;&#x27;) || null;
      if (u.searchParams.get(&#x27;v&#x27;)) return u.searchParams.get(&#x27;v&#x27;);
      const path &#x3D; u.pathname.split(&#x27;/&#x27;);
      const i &#x3D; path.indexOf(&#x27;embed&#x27;);
      return i !&#x3D;&#x3D; -1 &amp;&amp; path[i + 1] ? path[i + 1] : null;
    } catch {
      const m &#x3D; url.match(
        /(?:v&#x3D;|\/embed\/|youtu\.be\/)([A-Za-z0-9_-]{6,})/
      );
      return m?.[1] || null;
    }
  }

  goToPortfolio(username: string) {
    this.router.navigate([&#x27;learning/portfolio&#x27;, &#x27;@&#x27; + username]);
  }

  private getHtml5Duration(): number {
    const videoEl &#x3D;
      document.querySelector&lt;HTMLVideoElement&gt;(&#x27;video.video-player&#x27;);
    const d &#x3D; videoEl?.duration;
    return typeof d &#x3D;&#x3D;&#x3D; &#x27;number&#x27; &amp;&amp; Number.isFinite(d) ? d : 0;
  }

  /** Calcula y envía delta de progreso (%) desde un player de tiempo */
  private reportCompletedDelta(currentSec: number) {
    const d &#x3D; this.data();
    if (!d) return;

    const lcId &#x3D; d.learning_content?.id;
    const chapterId &#x3D; d.chapter.id;
    if (lcId &#x3D;&#x3D; null) return;

    // 1) Duración total según player activo
    let total &#x3D; 0;
    if (this.isYouTube()) total &#x3D; this.safeGetDurationFromYT() ?? 0;
    else total &#x3D; this.getHtml5Duration();

    if (!total || total &lt;&#x3D; 0) return; // aún no hay duración fiable

    // 2) Porcentaje actual y DELTA a reportar (incremental)
    const percent &#x3D; Math.min(100, (currentSec / total) * 100);
    const delta &#x3D; +Math.max(0, percent - this.lastPercentReported).toFixed(2);
    if (delta &lt; this.minDeltaPercent) return; // anti-spam

    this.sendProgressDelta(lcId, chapterId, delta, percent);
  }

  /** Envía el delta de progreso calculado al backend */
  private sendProgressDelta(
    lcId: number | string,
    chapterId: number,
    delta: number,
    newPercent: number
  ) {
    if (delta &lt;&#x3D; 0) return;

    this.lastPercentReported &#x3D; newPercent;

    this.feedbackSvc.updateProgress(lcId, { progress: delta }).subscribe({
      next: (res) &#x3D;&gt; {
        if (res?.data?.chapter_completed) {
          console.log(&#x60;Chapter ${chapterId} completed!&#x60;);
          this.bridge.markChapterCompleted(chapterId);
        }
        if (res?.data?.certificate_issued) {
          this.notificationBridge.increment(1);
          this.bridge.notifyCertificateIssued();
          
        }
      },
      error: () &#x3D;&gt; {
        // silencioso
      }
    });
  }

  /** Marca como 100% completado un contenido sin duración (PDF, TMP, imagen) */
  private markNonTimeContentCompleted() {
    const d &#x3D; this.data();
    if (!d) return;

    const lcId &#x3D; d.learning_content?.id;
    const chapterId &#x3D; d.chapter.id;
    if (lcId &#x3D;&#x3D; null) return;

    // 1) Asegurar registro de vista
    this.feedbackSvc
      .setContent(lcId, 1)
      .pipe(catchError(() &#x3D;&gt; of(null)))
      .subscribe();

    // 2) Mandar solo el delta que falta hasta 100
    const delta &#x3D; +Math.max(0, 100 - this.lastPercentReported).toFixed(2);
    if (delta &lt;&#x3D; 0) return;

    this.sendProgressDelta(lcId, chapterId, delta, 100);
  }

  private get courseId(): string | null {
    return this.route.parent?.snapshot.paramMap.get(&#x27;id&#x27;) ?? null;
  }

  // ---- Código de acceso (input grande) ----
  private focusCodeInput() {
    const el &#x3D; this.codeInput?.nativeElement;
    if (el) {
      el.focus();
      el.select?.();
    }
  }

  private allowedChar(c: string): boolean {
    // Mismo set que genera el backend: 23456789ABCDEFGHJKLMNPQRSTUVWXYZ (sin 0,O,1,I,L)
    return /^[23456789ABCDEFGHJKLMNPQRSTUVWXYZ]$/.test(c);
  }

  onCodeInput(ev: Event) {
    const input &#x3D; ev.target as HTMLInputElement;
    let value &#x3D; (input.value || &#x27;&#x27;).toUpperCase();

    value &#x3D; value.replace(/[^23456789ABCDEFGHJKLMNPQRSTUVWXYZ]/g, &#x27;&#x27;);
    if (value.length &gt; this.codeLength) value &#x3D; value.slice(0, this.codeLength);

    this.code.set(value);

    if (input.value !&#x3D;&#x3D; value) {
      input.value &#x3D; value;
    }
  }

  submitCode() {
    const code &#x3D; this.code();
    if (code.length !&#x3D;&#x3D; this.codeLength) return;

    this.enrolling.set(true);
    this.codeError.set(null);

    this.feedbackSvc.enrollPrivate(code).subscribe({
      next: () &#x3D;&gt; {
        this.bridge.setRegistered(true);
        this.enrolling.set(false);
        this.dialogCodeShow &#x3D; false;
        this.code.set(&#x27;&#x27;);
      },
      error: (err) &#x3D;&gt; {
        this.codeError.set(
          err?.error?.message || &#x27;Código inválido o curso no disponible.&#x27;
        );
        this.enrolling.set(false);
        this.focusCodeInput();
      }
    });
  }

  // ---- Acciones de documentos/archivos ----
  openPdfViewer() {
    this.markNonTimeContentCompleted();
    this.dialogPdfShow &#x3D; true;
  }

  downloadFile(url: string) {
    if (!url) return;
    this.markNonTimeContentCompleted();

    try {
      const link &#x3D; document.createElement(&#x27;a&#x27;);
      link.href &#x3D; url;
      link.target &#x3D; &#x27;_blank&#x27;;
      link.download &#x3D; &#x27;&#x27;;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch {}
  }

  onImageLoaded() {
    this.markNonTimeContentCompleted();
  }

  toTest() {
    this.router.navigate([&#x27;test&#x27;], { relativeTo: this.route.parent });
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'Window.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
